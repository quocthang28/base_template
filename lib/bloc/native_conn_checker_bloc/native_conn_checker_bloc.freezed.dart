// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'native_conn_checker_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$NativeConnCheckerEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialEvent,
    required TResult Function() initializeConCheckerEvent,
    required TResult Function() notifyDisconnectedEvent,
    required TResult Function() notifyConnectedEvent,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialEvent,
    TResult Function()? initializeConCheckerEvent,
    TResult Function()? notifyDisconnectedEvent,
    TResult Function()? notifyConnectedEvent,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialEvent,
    TResult Function()? initializeConCheckerEvent,
    TResult Function()? notifyDisconnectedEvent,
    TResult Function()? notifyConnectedEvent,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialEvent value) initialEvent,
    required TResult Function(_InitializeConCheckerEvent value)
        initializeConCheckerEvent,
    required TResult Function(_NotifyDisconnectedEvent value)
        notifyDisconnectedEvent,
    required TResult Function(_NotifyConnectedEvent value) notifyConnectedEvent,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initialEvent,
    TResult Function(_InitializeConCheckerEvent value)?
        initializeConCheckerEvent,
    TResult Function(_NotifyDisconnectedEvent value)? notifyDisconnectedEvent,
    TResult Function(_NotifyConnectedEvent value)? notifyConnectedEvent,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initialEvent,
    TResult Function(_InitializeConCheckerEvent value)?
        initializeConCheckerEvent,
    TResult Function(_NotifyDisconnectedEvent value)? notifyDisconnectedEvent,
    TResult Function(_NotifyConnectedEvent value)? notifyConnectedEvent,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NativeConnCheckerEventCopyWith<$Res> {
  factory $NativeConnCheckerEventCopyWith(NativeConnCheckerEvent value,
          $Res Function(NativeConnCheckerEvent) then) =
      _$NativeConnCheckerEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$NativeConnCheckerEventCopyWithImpl<$Res>
    implements $NativeConnCheckerEventCopyWith<$Res> {
  _$NativeConnCheckerEventCopyWithImpl(this._value, this._then);

  final NativeConnCheckerEvent _value;
  // ignore: unused_field
  final $Res Function(NativeConnCheckerEvent) _then;
}

/// @nodoc
abstract class _$$_InitialEventCopyWith<$Res> {
  factory _$$_InitialEventCopyWith(
          _$_InitialEvent value, $Res Function(_$_InitialEvent) then) =
      __$$_InitialEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_InitialEventCopyWithImpl<$Res>
    extends _$NativeConnCheckerEventCopyWithImpl<$Res>
    implements _$$_InitialEventCopyWith<$Res> {
  __$$_InitialEventCopyWithImpl(
      _$_InitialEvent _value, $Res Function(_$_InitialEvent) _then)
      : super(_value, (v) => _then(v as _$_InitialEvent));

  @override
  _$_InitialEvent get _value => super._value as _$_InitialEvent;
}

/// @nodoc

class _$_InitialEvent implements _InitialEvent {
  const _$_InitialEvent();

  @override
  String toString() {
    return 'NativeConnCheckerEvent.initialEvent()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_InitialEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialEvent,
    required TResult Function() initializeConCheckerEvent,
    required TResult Function() notifyDisconnectedEvent,
    required TResult Function() notifyConnectedEvent,
  }) {
    return initialEvent();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialEvent,
    TResult Function()? initializeConCheckerEvent,
    TResult Function()? notifyDisconnectedEvent,
    TResult Function()? notifyConnectedEvent,
  }) {
    return initialEvent?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialEvent,
    TResult Function()? initializeConCheckerEvent,
    TResult Function()? notifyDisconnectedEvent,
    TResult Function()? notifyConnectedEvent,
    required TResult orElse(),
  }) {
    if (initialEvent != null) {
      return initialEvent();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialEvent value) initialEvent,
    required TResult Function(_InitializeConCheckerEvent value)
        initializeConCheckerEvent,
    required TResult Function(_NotifyDisconnectedEvent value)
        notifyDisconnectedEvent,
    required TResult Function(_NotifyConnectedEvent value) notifyConnectedEvent,
  }) {
    return initialEvent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initialEvent,
    TResult Function(_InitializeConCheckerEvent value)?
        initializeConCheckerEvent,
    TResult Function(_NotifyDisconnectedEvent value)? notifyDisconnectedEvent,
    TResult Function(_NotifyConnectedEvent value)? notifyConnectedEvent,
  }) {
    return initialEvent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initialEvent,
    TResult Function(_InitializeConCheckerEvent value)?
        initializeConCheckerEvent,
    TResult Function(_NotifyDisconnectedEvent value)? notifyDisconnectedEvent,
    TResult Function(_NotifyConnectedEvent value)? notifyConnectedEvent,
    required TResult orElse(),
  }) {
    if (initialEvent != null) {
      return initialEvent(this);
    }
    return orElse();
  }
}

abstract class _InitialEvent implements NativeConnCheckerEvent {
  const factory _InitialEvent() = _$_InitialEvent;
}

/// @nodoc
abstract class _$$_InitializeConCheckerEventCopyWith<$Res> {
  factory _$$_InitializeConCheckerEventCopyWith(
          _$_InitializeConCheckerEvent value,
          $Res Function(_$_InitializeConCheckerEvent) then) =
      __$$_InitializeConCheckerEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_InitializeConCheckerEventCopyWithImpl<$Res>
    extends _$NativeConnCheckerEventCopyWithImpl<$Res>
    implements _$$_InitializeConCheckerEventCopyWith<$Res> {
  __$$_InitializeConCheckerEventCopyWithImpl(
      _$_InitializeConCheckerEvent _value,
      $Res Function(_$_InitializeConCheckerEvent) _then)
      : super(_value, (v) => _then(v as _$_InitializeConCheckerEvent));

  @override
  _$_InitializeConCheckerEvent get _value =>
      super._value as _$_InitializeConCheckerEvent;
}

/// @nodoc

class _$_InitializeConCheckerEvent implements _InitializeConCheckerEvent {
  const _$_InitializeConCheckerEvent();

  @override
  String toString() {
    return 'NativeConnCheckerEvent.initializeConCheckerEvent()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_InitializeConCheckerEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialEvent,
    required TResult Function() initializeConCheckerEvent,
    required TResult Function() notifyDisconnectedEvent,
    required TResult Function() notifyConnectedEvent,
  }) {
    return initializeConCheckerEvent();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialEvent,
    TResult Function()? initializeConCheckerEvent,
    TResult Function()? notifyDisconnectedEvent,
    TResult Function()? notifyConnectedEvent,
  }) {
    return initializeConCheckerEvent?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialEvent,
    TResult Function()? initializeConCheckerEvent,
    TResult Function()? notifyDisconnectedEvent,
    TResult Function()? notifyConnectedEvent,
    required TResult orElse(),
  }) {
    if (initializeConCheckerEvent != null) {
      return initializeConCheckerEvent();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialEvent value) initialEvent,
    required TResult Function(_InitializeConCheckerEvent value)
        initializeConCheckerEvent,
    required TResult Function(_NotifyDisconnectedEvent value)
        notifyDisconnectedEvent,
    required TResult Function(_NotifyConnectedEvent value) notifyConnectedEvent,
  }) {
    return initializeConCheckerEvent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initialEvent,
    TResult Function(_InitializeConCheckerEvent value)?
        initializeConCheckerEvent,
    TResult Function(_NotifyDisconnectedEvent value)? notifyDisconnectedEvent,
    TResult Function(_NotifyConnectedEvent value)? notifyConnectedEvent,
  }) {
    return initializeConCheckerEvent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initialEvent,
    TResult Function(_InitializeConCheckerEvent value)?
        initializeConCheckerEvent,
    TResult Function(_NotifyDisconnectedEvent value)? notifyDisconnectedEvent,
    TResult Function(_NotifyConnectedEvent value)? notifyConnectedEvent,
    required TResult orElse(),
  }) {
    if (initializeConCheckerEvent != null) {
      return initializeConCheckerEvent(this);
    }
    return orElse();
  }
}

abstract class _InitializeConCheckerEvent implements NativeConnCheckerEvent {
  const factory _InitializeConCheckerEvent() = _$_InitializeConCheckerEvent;
}

/// @nodoc
abstract class _$$_NotifyDisconnectedEventCopyWith<$Res> {
  factory _$$_NotifyDisconnectedEventCopyWith(_$_NotifyDisconnectedEvent value,
          $Res Function(_$_NotifyDisconnectedEvent) then) =
      __$$_NotifyDisconnectedEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_NotifyDisconnectedEventCopyWithImpl<$Res>
    extends _$NativeConnCheckerEventCopyWithImpl<$Res>
    implements _$$_NotifyDisconnectedEventCopyWith<$Res> {
  __$$_NotifyDisconnectedEventCopyWithImpl(_$_NotifyDisconnectedEvent _value,
      $Res Function(_$_NotifyDisconnectedEvent) _then)
      : super(_value, (v) => _then(v as _$_NotifyDisconnectedEvent));

  @override
  _$_NotifyDisconnectedEvent get _value =>
      super._value as _$_NotifyDisconnectedEvent;
}

/// @nodoc

class _$_NotifyDisconnectedEvent implements _NotifyDisconnectedEvent {
  const _$_NotifyDisconnectedEvent();

  @override
  String toString() {
    return 'NativeConnCheckerEvent.notifyDisconnectedEvent()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_NotifyDisconnectedEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialEvent,
    required TResult Function() initializeConCheckerEvent,
    required TResult Function() notifyDisconnectedEvent,
    required TResult Function() notifyConnectedEvent,
  }) {
    return notifyDisconnectedEvent();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialEvent,
    TResult Function()? initializeConCheckerEvent,
    TResult Function()? notifyDisconnectedEvent,
    TResult Function()? notifyConnectedEvent,
  }) {
    return notifyDisconnectedEvent?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialEvent,
    TResult Function()? initializeConCheckerEvent,
    TResult Function()? notifyDisconnectedEvent,
    TResult Function()? notifyConnectedEvent,
    required TResult orElse(),
  }) {
    if (notifyDisconnectedEvent != null) {
      return notifyDisconnectedEvent();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialEvent value) initialEvent,
    required TResult Function(_InitializeConCheckerEvent value)
        initializeConCheckerEvent,
    required TResult Function(_NotifyDisconnectedEvent value)
        notifyDisconnectedEvent,
    required TResult Function(_NotifyConnectedEvent value) notifyConnectedEvent,
  }) {
    return notifyDisconnectedEvent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initialEvent,
    TResult Function(_InitializeConCheckerEvent value)?
        initializeConCheckerEvent,
    TResult Function(_NotifyDisconnectedEvent value)? notifyDisconnectedEvent,
    TResult Function(_NotifyConnectedEvent value)? notifyConnectedEvent,
  }) {
    return notifyDisconnectedEvent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initialEvent,
    TResult Function(_InitializeConCheckerEvent value)?
        initializeConCheckerEvent,
    TResult Function(_NotifyDisconnectedEvent value)? notifyDisconnectedEvent,
    TResult Function(_NotifyConnectedEvent value)? notifyConnectedEvent,
    required TResult orElse(),
  }) {
    if (notifyDisconnectedEvent != null) {
      return notifyDisconnectedEvent(this);
    }
    return orElse();
  }
}

abstract class _NotifyDisconnectedEvent implements NativeConnCheckerEvent {
  const factory _NotifyDisconnectedEvent() = _$_NotifyDisconnectedEvent;
}

/// @nodoc
abstract class _$$_NotifyConnectedEventCopyWith<$Res> {
  factory _$$_NotifyConnectedEventCopyWith(_$_NotifyConnectedEvent value,
          $Res Function(_$_NotifyConnectedEvent) then) =
      __$$_NotifyConnectedEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_NotifyConnectedEventCopyWithImpl<$Res>
    extends _$NativeConnCheckerEventCopyWithImpl<$Res>
    implements _$$_NotifyConnectedEventCopyWith<$Res> {
  __$$_NotifyConnectedEventCopyWithImpl(_$_NotifyConnectedEvent _value,
      $Res Function(_$_NotifyConnectedEvent) _then)
      : super(_value, (v) => _then(v as _$_NotifyConnectedEvent));

  @override
  _$_NotifyConnectedEvent get _value => super._value as _$_NotifyConnectedEvent;
}

/// @nodoc

class _$_NotifyConnectedEvent implements _NotifyConnectedEvent {
  const _$_NotifyConnectedEvent();

  @override
  String toString() {
    return 'NativeConnCheckerEvent.notifyConnectedEvent()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_NotifyConnectedEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialEvent,
    required TResult Function() initializeConCheckerEvent,
    required TResult Function() notifyDisconnectedEvent,
    required TResult Function() notifyConnectedEvent,
  }) {
    return notifyConnectedEvent();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialEvent,
    TResult Function()? initializeConCheckerEvent,
    TResult Function()? notifyDisconnectedEvent,
    TResult Function()? notifyConnectedEvent,
  }) {
    return notifyConnectedEvent?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialEvent,
    TResult Function()? initializeConCheckerEvent,
    TResult Function()? notifyDisconnectedEvent,
    TResult Function()? notifyConnectedEvent,
    required TResult orElse(),
  }) {
    if (notifyConnectedEvent != null) {
      return notifyConnectedEvent();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialEvent value) initialEvent,
    required TResult Function(_InitializeConCheckerEvent value)
        initializeConCheckerEvent,
    required TResult Function(_NotifyDisconnectedEvent value)
        notifyDisconnectedEvent,
    required TResult Function(_NotifyConnectedEvent value) notifyConnectedEvent,
  }) {
    return notifyConnectedEvent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initialEvent,
    TResult Function(_InitializeConCheckerEvent value)?
        initializeConCheckerEvent,
    TResult Function(_NotifyDisconnectedEvent value)? notifyDisconnectedEvent,
    TResult Function(_NotifyConnectedEvent value)? notifyConnectedEvent,
  }) {
    return notifyConnectedEvent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initialEvent,
    TResult Function(_InitializeConCheckerEvent value)?
        initializeConCheckerEvent,
    TResult Function(_NotifyDisconnectedEvent value)? notifyDisconnectedEvent,
    TResult Function(_NotifyConnectedEvent value)? notifyConnectedEvent,
    required TResult orElse(),
  }) {
    if (notifyConnectedEvent != null) {
      return notifyConnectedEvent(this);
    }
    return orElse();
  }
}

abstract class _NotifyConnectedEvent implements NativeConnCheckerEvent {
  const factory _NotifyConnectedEvent() = _$_NotifyConnectedEvent;
}

/// @nodoc
mixin _$NativeConnCheckerState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialState,
    required TResult Function() connectionLostState,
    required TResult Function() connectionRestoredState,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialState,
    TResult Function()? connectionLostState,
    TResult Function()? connectionRestoredState,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialState,
    TResult Function()? connectionLostState,
    TResult Function()? connectionRestoredState,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialState value) initialState,
    required TResult Function(_ConnectionLostState value) connectionLostState,
    required TResult Function(_ConnectionRestoredState value)
        connectionRestoredState,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_InitialState value)? initialState,
    TResult Function(_ConnectionLostState value)? connectionLostState,
    TResult Function(_ConnectionRestoredState value)? connectionRestoredState,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialState value)? initialState,
    TResult Function(_ConnectionLostState value)? connectionLostState,
    TResult Function(_ConnectionRestoredState value)? connectionRestoredState,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NativeConnCheckerStateCopyWith<$Res> {
  factory $NativeConnCheckerStateCopyWith(NativeConnCheckerState value,
          $Res Function(NativeConnCheckerState) then) =
      _$NativeConnCheckerStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$NativeConnCheckerStateCopyWithImpl<$Res>
    implements $NativeConnCheckerStateCopyWith<$Res> {
  _$NativeConnCheckerStateCopyWithImpl(this._value, this._then);

  final NativeConnCheckerState _value;
  // ignore: unused_field
  final $Res Function(NativeConnCheckerState) _then;
}

/// @nodoc
abstract class _$$_InitialStateCopyWith<$Res> {
  factory _$$_InitialStateCopyWith(
          _$_InitialState value, $Res Function(_$_InitialState) then) =
      __$$_InitialStateCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_InitialStateCopyWithImpl<$Res>
    extends _$NativeConnCheckerStateCopyWithImpl<$Res>
    implements _$$_InitialStateCopyWith<$Res> {
  __$$_InitialStateCopyWithImpl(
      _$_InitialState _value, $Res Function(_$_InitialState) _then)
      : super(_value, (v) => _then(v as _$_InitialState));

  @override
  _$_InitialState get _value => super._value as _$_InitialState;
}

/// @nodoc

class _$_InitialState implements _InitialState {
  const _$_InitialState();

  @override
  String toString() {
    return 'NativeConnCheckerState.initialState()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_InitialState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialState,
    required TResult Function() connectionLostState,
    required TResult Function() connectionRestoredState,
  }) {
    return initialState();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialState,
    TResult Function()? connectionLostState,
    TResult Function()? connectionRestoredState,
  }) {
    return initialState?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialState,
    TResult Function()? connectionLostState,
    TResult Function()? connectionRestoredState,
    required TResult orElse(),
  }) {
    if (initialState != null) {
      return initialState();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialState value) initialState,
    required TResult Function(_ConnectionLostState value) connectionLostState,
    required TResult Function(_ConnectionRestoredState value)
        connectionRestoredState,
  }) {
    return initialState(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_InitialState value)? initialState,
    TResult Function(_ConnectionLostState value)? connectionLostState,
    TResult Function(_ConnectionRestoredState value)? connectionRestoredState,
  }) {
    return initialState?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialState value)? initialState,
    TResult Function(_ConnectionLostState value)? connectionLostState,
    TResult Function(_ConnectionRestoredState value)? connectionRestoredState,
    required TResult orElse(),
  }) {
    if (initialState != null) {
      return initialState(this);
    }
    return orElse();
  }
}

abstract class _InitialState implements NativeConnCheckerState {
  const factory _InitialState() = _$_InitialState;
}

/// @nodoc
abstract class _$$_ConnectionLostStateCopyWith<$Res> {
  factory _$$_ConnectionLostStateCopyWith(_$_ConnectionLostState value,
          $Res Function(_$_ConnectionLostState) then) =
      __$$_ConnectionLostStateCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_ConnectionLostStateCopyWithImpl<$Res>
    extends _$NativeConnCheckerStateCopyWithImpl<$Res>
    implements _$$_ConnectionLostStateCopyWith<$Res> {
  __$$_ConnectionLostStateCopyWithImpl(_$_ConnectionLostState _value,
      $Res Function(_$_ConnectionLostState) _then)
      : super(_value, (v) => _then(v as _$_ConnectionLostState));

  @override
  _$_ConnectionLostState get _value => super._value as _$_ConnectionLostState;
}

/// @nodoc

class _$_ConnectionLostState implements _ConnectionLostState {
  const _$_ConnectionLostState();

  @override
  String toString() {
    return 'NativeConnCheckerState.connectionLostState()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_ConnectionLostState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialState,
    required TResult Function() connectionLostState,
    required TResult Function() connectionRestoredState,
  }) {
    return connectionLostState();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialState,
    TResult Function()? connectionLostState,
    TResult Function()? connectionRestoredState,
  }) {
    return connectionLostState?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialState,
    TResult Function()? connectionLostState,
    TResult Function()? connectionRestoredState,
    required TResult orElse(),
  }) {
    if (connectionLostState != null) {
      return connectionLostState();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialState value) initialState,
    required TResult Function(_ConnectionLostState value) connectionLostState,
    required TResult Function(_ConnectionRestoredState value)
        connectionRestoredState,
  }) {
    return connectionLostState(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_InitialState value)? initialState,
    TResult Function(_ConnectionLostState value)? connectionLostState,
    TResult Function(_ConnectionRestoredState value)? connectionRestoredState,
  }) {
    return connectionLostState?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialState value)? initialState,
    TResult Function(_ConnectionLostState value)? connectionLostState,
    TResult Function(_ConnectionRestoredState value)? connectionRestoredState,
    required TResult orElse(),
  }) {
    if (connectionLostState != null) {
      return connectionLostState(this);
    }
    return orElse();
  }
}

abstract class _ConnectionLostState implements NativeConnCheckerState {
  const factory _ConnectionLostState() = _$_ConnectionLostState;
}

/// @nodoc
abstract class _$$_ConnectionRestoredStateCopyWith<$Res> {
  factory _$$_ConnectionRestoredStateCopyWith(_$_ConnectionRestoredState value,
          $Res Function(_$_ConnectionRestoredState) then) =
      __$$_ConnectionRestoredStateCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_ConnectionRestoredStateCopyWithImpl<$Res>
    extends _$NativeConnCheckerStateCopyWithImpl<$Res>
    implements _$$_ConnectionRestoredStateCopyWith<$Res> {
  __$$_ConnectionRestoredStateCopyWithImpl(_$_ConnectionRestoredState _value,
      $Res Function(_$_ConnectionRestoredState) _then)
      : super(_value, (v) => _then(v as _$_ConnectionRestoredState));

  @override
  _$_ConnectionRestoredState get _value =>
      super._value as _$_ConnectionRestoredState;
}

/// @nodoc

class _$_ConnectionRestoredState implements _ConnectionRestoredState {
  const _$_ConnectionRestoredState();

  @override
  String toString() {
    return 'NativeConnCheckerState.connectionRestoredState()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ConnectionRestoredState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialState,
    required TResult Function() connectionLostState,
    required TResult Function() connectionRestoredState,
  }) {
    return connectionRestoredState();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialState,
    TResult Function()? connectionLostState,
    TResult Function()? connectionRestoredState,
  }) {
    return connectionRestoredState?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialState,
    TResult Function()? connectionLostState,
    TResult Function()? connectionRestoredState,
    required TResult orElse(),
  }) {
    if (connectionRestoredState != null) {
      return connectionRestoredState();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialState value) initialState,
    required TResult Function(_ConnectionLostState value) connectionLostState,
    required TResult Function(_ConnectionRestoredState value)
        connectionRestoredState,
  }) {
    return connectionRestoredState(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_InitialState value)? initialState,
    TResult Function(_ConnectionLostState value)? connectionLostState,
    TResult Function(_ConnectionRestoredState value)? connectionRestoredState,
  }) {
    return connectionRestoredState?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialState value)? initialState,
    TResult Function(_ConnectionLostState value)? connectionLostState,
    TResult Function(_ConnectionRestoredState value)? connectionRestoredState,
    required TResult orElse(),
  }) {
    if (connectionRestoredState != null) {
      return connectionRestoredState(this);
    }
    return orElse();
  }
}

abstract class _ConnectionRestoredState implements NativeConnCheckerState {
  const factory _ConnectionRestoredState() = _$_ConnectionRestoredState;
}
